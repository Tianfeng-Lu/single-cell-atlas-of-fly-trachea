---
title: "RNA_velocity"
output: html_notebook
---

# Part 4'
## RNA velocity
```{r setup, include=FALSE}
knitr::opts_knit$set(root.dir = "/home/zju/tianfeng/CAD")
```

```{r}
# library(velocyto.R)
library(SeuratWrappers)
library(Seurat)
library(velocity.R)
source("./utils/tianfengRwrappers.R")
```

## functionset
```{r}
## 拆分barcode, 然后再添加新的数字后缀，使之与CAD_merge的细胞barcode相符合,这里的n为loomfile在CAD_merge中对应的序号
preprocess <- function(loom_path, n){
  velodata <- ReadVelocity(file = loom_path)
  
  #匹配两次的barcode
  tfunc <- function(s)
  {
    s <- strsplit(s,".*:",fixed = F)[[1]][2]
    s <- strsplit(s,"x",fixed = T)[[1]]
    s <- paste(s,as.character(n),sep = "-")
    return(s)
  }
  
  velodata[["spliced"]]@Dimnames[[2]] = as.character(lapply(velodata[["spliced"]]@Dimnames[[2]],tfunc))
  velodata[["unspliced"]]@Dimnames[[2]] = as.character(lapply(velodata[["unspliced"]]@Dimnames[[2]],tfunc))
  velodata[["ambiguous"]]@Dimnames[[2]] = as.character(lapply(velodata[["ambiguous"]]@Dimnames[[2]],tfunc))
  return(velodata)
}

#' Title
#'
#' @param list1 cell id needed to be transformed
#' @param list2 reference cell id 
#'
#' @return transformed list1
#' 
#' @examples
surfix_mapper <- function(list1, list2){
  surfix1 <- unique(list1 %>% sapply(., function(x){strsplit(x,"-", fixed = T)[[1]][2]}))
  surfix2 <- unique(list2 %>% sapply(., function(x){strsplit(x,"-", fixed = T)[[1]][2]}))
  names(surfix2) <- surfix1
  
  transformed_list1 <- lapply(list1, function(x){
    cell_id <- strsplit(x,"-", fixed = T)[[1]][1]
    old_surfix <- strsplit(x,"-", fixed = T)[[1]][2]
    paste0(cell_id, "-", surfix2[old_surfix])
    }) %>% as.character()

  return(transformed_list1)

}


```

```
sample_id,molecule_h5,type
sample_id,molecule_h5,type
sp1,CAD0322/outs/molecule_info.h5,sample
sp2,CAD0406/outs/molecule_info.h5,sample
sp5,CAD230206/outs/molecule_info.h5,sample
ctrl2,CAD0519/outs/molecule_info.h5,ctrl
ctrl3,CAD0615/outs/molecule_info.h5,ctrl
ctrl4,CAD1026/outs/molecule_info.h5,ctrl

此外, sp3和ctrl1分别合并
```

```{r}
#首先需要取并集，然后使用已有的umap，在其上绘制速率图
## 拆分barcode, 然后再添加新的数字后缀，使之与CAD_merge的细胞barcode相符合,这里的n为loomfile在CAD_merge中对应的序号, 看aggregation.csv
unique(CAD_ECs$orig.ident)
sp1_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD0322.loom",1))
sp2_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD0406.loom",2))
sp5_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD230206.loom",3))
ctrl2_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD0519.loom",4))
ctrl3_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD0615.loom",5))
ctrl4_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD1026.loom",6))
ctrl1_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD0424.loom",7))
sp3_velo <- as.Seurat(x = preprocess("./processed_data_file/velocyto_result/CAD0425.loom",8))

merge_velo <- merge(sp1_velo, c(sp2_velo,sp5_velo,ctrl2_velo, ctrl3_velo,ctrl4_velo, ctrl1_velo, sp3_velo))

merge_velo <- merge_velo %>% 
    PercentageFeatureSet(pattern = "^MT-", col.name = "percent.mt") %>%
    SCTransform(vars.to.regress = "percent.mt", verbose = F,assay = "spliced") %>% 
    RunPCA() %>% FindNeighbors(dims = 1:20) %>% 
    RunUMAP(dims = 1:20) %>% 
    FindClusters(resolution = 0.1)


EC_cells <- surfix_mapper(colnames(CAD_ECs), colnames(merge_velo)) # 转换CAD_ECs的cell id
merge_velo <- subset(merge_velo, cells = EC_cells) # 13979 cells in total
assertthat::are_equal(ncol(merge_velo), ncol(CAD_ECs))
rm(sp1_velo, sp2_velo,sp5_velo,ctrl2_velo, ctrl3_velo,ctrl4_velo, ctrl1_velo, sp3_velo)

merge_velo@reductions[["umap"]] <- CAD_ECs@reductions[["umap"]]
rownames(merge_velo@reductions[["umap"]]@cell.embeddings) <- colnames(merge_velo)

DimPlot(merge_velo, reduction = "umap", pt.size = 0.5, label = T)
merge_velo$Classification1 <- CAD_ECs$celltype
Idents(merge_velo) <- merge_velo$Classification1
merge_velo@assays[["RNA"]] <- CAD_ECs@assays[["RNA"]]

saveRDS(merge_velo,"./processed_data_file/merge_velo.rds") #EC cells
# saveRDS(subset(merge_velo,ident = c(1,2,3,6)),"merge_velo_stromal.rds")
# saveRDS(subset(merge_velo,ident = c(0,5)),"merge_velo_EC.rds")
```


```{r}
# ident.colors <- colors_list[1:length(x = levels(x = sp1_velo))]
# names(x = ident.colors) <- levels(x = sp1_velo)
# cell.colors <- ident.colors[Idents(object = sp1_velo)]
# 
# names(x = cell.colors) <- colnames(x = sp1_velo)
# 
# png("velocity.png")
# show.velocity.on.embedding.cor(emb = Embeddings(object = sp1_velo, reduction = "umap"), vel = Tool(object = sp1_velo, slot = "RunVelocity"), n = 200, scale = "sqrt", cell.colors = ac(x = cell.colors, alpha = 0.5), 
#     cex = 0.8, arrow.scale = 3, show.grid.flow = TRUE, min.grid.cell.mass = 0.5, grid.n = 40, arrow.lwd = 1, 
#     do.par = FALSE, cell.border.alpha = 0.1)
# dev.off()

```

## export for scvelo in python
```{r}
# merge_velo <- readRDS("./processed_data_file/merge_velo.rds")
h5ad_output <- "./processed_data_file/CAD_EC_velo.h5ad"  
reticulate::use_miniconda("/data/zju/ty/miniconda/envs/scvelo")
library(reticulate)
library(Matrix)
writeMM(t(merge_velo@assays$RNA@counts), file='./combined.mtx')
writeMM(t(merge_velo@assays$spliced@counts), file='./spliced.mtx')
writeMM(t(merge_velo@assays$unspliced@counts), file='./unspliced.mtx')
write.csv(rownames(merge_velo@assays$spliced@counts), file = "./genes.csv", row.names = FALSE)
write.csv(merge_velo@reductions$umap@cell.embeddings, file = "./umap.csv", row.names = FALSE)
write.csv(merge_velo@reductions$pca@cell.embeddings, file = "./pca.csv", row.names = FALSE)
write.csv(colnames(merge_velo@assays$spliced@counts), file = "./cells.csv", row.names = FALSE)
write.csv(merge_velo@meta.data, file = "./meta.csv", row.names = FALSE)
source_python('./utils/build.py')
build(h5ad_output, pca = TRUE, umap = TRUE)
file.remove('./combined.mtx')
file.remove('./spliced.mtx')
file.remove('./unspliced.mtx')
file.remove('./genes.csv')
file.remove('./cells.csv')
file.remove('./umap.csv')
file.remove('./pca.csv')
file.remove('./meta.csv')
```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.