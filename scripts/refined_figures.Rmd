---
title: "figs functions prototype"
output:
  html_document:
    df_print: paged
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

# 初始化
```{r init}
library(ggplot2)
library(Seurat)
library(RColorBrewer)
library(MySeuratWrappers)
library(ggpubr)
library(cowplot)
library(pheatmap)
library(viridis)
library(reshape2)
library(ggridges) 
library(hrbrthemes)
library(clusterProfiler)
library(extrafont)
#remotes::install_github("lyc-1995/MySeuratWrappers")#通过链接安装包
```


```{r init}
larva <- readRDS("./fly_merge.rds")
# larva <- subset(larva, cells = CellSelector(plot = DimPlot(larva, reduction = "umap"))) #去除边角的细胞

display.brewer.all(type = "qual") #色彩板

colors_list <- c("darkolivegreen2","lightpink","lightblue2","#00F5FF","#FFA500","plum2","#FF6A6A","#7FFFD4", "#AB82FF")
colors_list <- c(brewer.pal(7,"Set2"),brewer.pal(10,"Set3")[2:6],brewer.pal(10,"Set3")[10],"darkolivegreen2","plum2")
#nlevels(as.factor(larva$'sub.cluster')) 


barplot(matrix(rep(1,15)), col=colors_list, axes=F)
```

# function set
## nlevels(as.factor(larva$group.by)) 返回聚类的数量
```{r featureplot}
f <- function (gene,obj=larva, cols = c("lightgrey","#ff2121"), ...) 
  {FeaturePlot(obj, pt.size = 0.8, features = gene, cols = cols,
                                 label = TRUE, label.size = 5,) + theme(axis.line = element_blank(), 
                                 axis.text = element_blank(), axis.ticks = element_blank(), 
                                 axis.title = element_blank())}
dhm <- function(gene,obj=larva, ...) {DoHeatmap(obj, features = gene, group.colors = colors_list,size = 4) + scale_fill_gradientn(colors = c("#1E90FF", "white", "#ff2121"))} #修正的doheatmap绘图颜色

umapplot <- function(obj = larva, group.by = NULL, ...){
  DimPlot(obj, reduction = "umap",cols = colors_list, label = TRUE, label.size = 3.5 ,pt.size = 0.8, group.by = group.by) + xlab("UMAP 1") + ylab("UMAP 2") +  guides(colour = guide_legend(override.aes = list(size = 5))) + theme(axis.line = element_line(arrow = arrow(length = unit(0.2, 'cm')))) + scale_y_continuous(limits = c(-10,10), breaks = NULL) +  scale_x_continuous(limits = c(-10,10), breaks = NULL)
  }
```

# umap
## Return: 
umap_plot
```{r umap, include=FALSE}
umap_plot <- umapplot(larva)
#ggsave(filename = "larva_umap.svg", device = svg, height = 6, width = 7, plot = umap_plot) #对svg调整坐标轴
```

# markers overview
## Return:
markers_heatmap
```{r markers, fig.height=8, fig.width=15}
larva.markers <- FindAllMarkers(larva, min.pct = 0.5, logfc.threshold = 0.5)
top5markers <- larva.markers %>% group_by(cluster) %>% slice_max(n = 5, order_by = avg_logFC)
markers_heatmap <- dhm(top5markers$gene, larva)
#ggsave(filename = paste0("markers",".tiff"), device = tiff, height = 8, width = 12, plot = markers_heatmap) #对svg调整坐标轴
```

# dotplot
## Return:
dotplot
```{r dotplot}
top3markers <- larva.markers %>% group_by(cluster) %>% slice_max(n = 3, order_by = avg_logFC)
dotplot <- DotPlot(larva, features = top3markers$gene, cols = c("lightgrey","#ff2121")) + coord_flip() + RotatedAxis() + theme_classic() #用来获得白色 而不是透明的背景
#ggsave(filename = paste0("top3dotplot",".svg"), device = svg, height = 12, width = 12, plot = dotplot)
# Dotplot(top3markers$gene, larva)
```

#单个基因featureplot
## Return:
gene_plot
```{r markers, fig.height=8, fig.width=15}
gene_plot <- f("Gasp")
#ggsave(filename = paste0(gene_name,".svg"), device = svg, height = 5, width = 6, plot = gene_plot) #对svg调整坐标轴
```


#两个基因umap共定位 
## Return:
doublegene_featureplot
```{r markers, fig.height=8, fig.width=15}
gene_name <- c("N","Dl")
doublegene_featureplot <- FeaturePlot(larva, pt.size = 0.8, features = gene_name, cols = c("lightgrey","deeppink","#1E90FF"), label = TRUE, blend = T) + theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank())
#ggsave(filename = paste0(gene_name[1],"vs",gene_name[2],".svg"), device = svg, height = 5, width = 20, plot = doublegene_featureplot) #对svg调整坐标轴
```

# 多基因堆叠小提琴图 
## Return:
violin_plot
```{r markers, fig.height=8, fig.width=15}
top2markers <- larva.markers %>% group_by(cluster) %>% slice_max(n = 2, order_by = avg_logFC)
gene_name <- top2markers$gene
# plot <- VlnPlot(larva, features = gene_name, stack=T, pt.size=0, cols = colors_list, #颜色 
#         direction = "vertical", #horizontal 水平作图  vertical
#         x.lab = '', y.lab = '')+ #横纵轴不标记任何东西 
#   theme(axis.text.y = element_blank(), axis.ticks.y = element_blank()) #不显示坐标刻度

violin_plot <- VlnPlot(larva, features = gene_name, stack=T, pt.size=0, cols = colors_list, #颜色 
        direction = "horizontal", #horizontal 水平作图  vertical
        x.lab = '', y.lab = '')+ #横纵轴不标记任何东西 
  theme(axis.text.x = element_blank(), axis.ticks.x = element_blank()) #不显示坐标刻度

#ggsave(filename = paste0("top2GenesH",".svg"), device = svg, height = 8, width = 12, plot = violin_plot)
```

# 多图featureplot
## Return:
mulit_featureplot
```{r markers, fig.height=8, fig.width=15}
gene_name <- c("bnl", "btl", "htl", "Egfr") #可视化的基因名称
figures <- lapply(gene_name, f)
mulit_featureplot <- plot_grid(plotlist = figures, labels = "AUTO", ncol = 2, nrow = 2, label_size = 18)
#ggsave(filename = paste0("M6","E(spl)mβ-HLH",".png"), device = png, height = 10, width = 12, plot = mulit_featureplot)
#rm(figures)
#plot
```

#每个cluster之间的相关性 和 RNAseq的交叉验证
## Return:
corheatmap    highexp_heatmap
```{r}
# larva <- readRDS("./larva_pt.rds")
#获取平均表达矩阵
aver_expr_mat <- c()
for(cluster_name in levels(larva@active.ident))
{
  temp <- as.matrix(GetAssayData(larva,slot = "data")[,WhichCells(larva,idents = cluster_name)])
  aver_expr_mat <- cbind(aver_expr_mat,apply(temp,1,mean))
}

colnames(aver_expr_mat) <- levels(larva@active.ident)
#选高差异表达
aver_expr_mat <- aver_expr_mat[larva@assays[["RNA"]]@var.features,]
cormat <- cor(aver_expr_mat, method = "pearson")
corheatmap <- pheatmap(cormat, breaks = unique(c(seq(0.6,1, length=400))), color = colorRampPalette(c("#1E90FF", "white", "#ff2121"))(400),border_color = NA, cluster_rows = T, cluster_cols = T, angle_col = 45, main = "Correlation Heatmap")
#ggsave(filename = paste0("correlation_heatmap",".svg"), device = svg, height = 8, width = 8, plot = corheatmap)


degs <- read.csv("./DEGs_from_smartSeq/up_DEGslist.csv",header = FALSE)
markergenes <- rownames(larva.markers)
hopefully <- intersect(degs$V1,markergenes)
highexprheatmap <- dhm(hopefully,obj = larva)
ggsave(filename = paste0("highexpr_tr5",".png"), device = png, height = 8, width = 12, plot = highexprheatmap)


#smartseq 交叉验证
highexp_genes <- read.csv("./DEGs_from_smartSeq/Pro vs Asp.csv", header = T,row.names = 1)
highexp_genes <- as.vector(highexp_genes$V1)

highexp_heatmap <- dhm(obj = larva, gene = highexp_genes[1:100]) + theme_void()



```

# 转录因子 SCENIC
## Return:
TFheatmap
```{r}
regulonActivity <- read.csv("./regulonActivity.csv",row.names = 1)
topTFs <- read.csv("./topRegulators.csv")
top5 <- topTFs %>% group_by(seuratCluster) %>% slice_max(n = 5, order_by = RelativeActivity)

#根据已知的top5更新行顺序
regulonActivity <- regulonActivity[sapply(top5$Regulon, function(e) {which(rownames(regulonActivity) == e)}), ]
#annotation_col <-  data.frame(cluster = factor(top5$seuratCluster), row.names = make.names(top5$Regulon,TRUE)) #make.names用来生成不冲突的行
regulonActivity <- regulonActivity[,c("DB","DT","NE","PC","SB","TC","VB")]

TFheatmap <- pheatmap(regulonActivity, breaks = unique(c(seq(-3,3, length=400))), 
                 color = colorRampPalette(c("#1E90FF", "white", "#ff2121"))(400),
                border_color = NA, cluster_rows = FALSE, cluster_cols = FALSE,
                main = "regulonActivity",angle_col = 45, show_rownames = T)
#ggsave(filename = paste0("regulonActivity",".svg"), device = svg, height = 8, width = 12, plot = TFheatmap)
```

# pseudotime featureplot
## Return:
pseudotime in featurePlot
```{r}
pseudotimePlot <- f("pseudotime", cols = c("hotpink","#1E90FF"))
#ggsave(filename = paste0("pt_featureplot2",".svg"), device = svg, height = 5, width = 6, plot = pseudotimePlot)
```

# 基因+拟时
## Return:
genewithpseudotime
```{r fig.height=5, fig.width=20}
datMat <- as.matrix(GetAssayData(larva,slot = "data"))
df <- data.frame(t(larva$pseudotime))
df <- do.call(data.frame,lapply(df, function(x){
  x = x/20
  replace(x, is.infinite(x),0)}))
rownames(df) <- "pseudotime"
colnames(df) <- colnames(datMat)
datMat <- rbind(df, datMat)

test <- CreateSeuratObject(counts = datMat)
test@reductions[["umap"]] <- larva@reductions[["umap"]]
test@active.ident <- larva@active.ident
# SetAssayData(larva,slot = "data", new.data = datMat)
#共定位
gene_name <- c("Tom","pseudotime")
genewithpseudotime <- FeaturePlot(test, pt.size = 0.8, slot = "counts",min.cutoff = 0, max.cutoff = 4, features = gene_name, cols = c("lightgrey","#1E90FF", "#ff2121"), label = TRUE, blend = T, blend.threshold = 0) + theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank())
#ggsave(filename = paste0(gene_name[1],"vs",gene_name[2],".png"), device = png, height = 5, width = 20, plot = genewithpseudotime)
```



```{r functionset}
#R的排序函数 order(), sort, rank()
#根据每个细胞的pseudotime值分成若干bins

make_bins <- function(cell.subset, nbins = 11)  
{
  ordered.cells <- BiocGenerics::rank(cell.subset$pseudotime)
  bins <- c()
  len <- length(cell.subset$pseudotime)
  for (i in c(1:len)) {
    bins[i] <- floor(ordered.cells[i]*nbins/len)  #创建一个长度为细胞数量的向量，存储每个细胞分别属于的拟时bin信息
  }
  Idents(cell.subset) <- as.factor(bins)
  cell.subset$bins <- bins
  return(cell.subset)
}


make_pseudotime_heatmap_bycells <- function(cell.subset,top_specific_marker_ids, topn_markers = 40){
  
  #根据细胞画图
  dhm(obj = cell.subset, gene = head(top_specific_marker_ids,topn_markers), group.by = "bins")
}

#根据组平均画图
#提取表达矩阵
make_pseudotime_heatmap_average <- function(cell.subset,top_specific_marker_ids, topn_markers = 40)
{
  mat <- c()
  #上述方法分出来的bins是从0开始的
  for(j in c(0:(nbins-1)))
  {
    temp <- as.matrix(GetAssayData(cell.subset,slot = "scale.data")[,WhichCells(cell.subset,idents = c(j))])
    mat <- cbind(mat,apply(temp,1,mean))
  }
  colnames(mat) <- as.factor(c(0:(nbins-1)))
  
  pheatmap(mat[head(top_specific_marker_ids,topn_markers),], breaks = unique(c(seq(-3,3, length=400))), 
                 color = colorRampPalette(c("#1E90FF", "white", "#ff2121"))(400),
                border_color = NA, cluster_rows = FALSE, cluster_cols = FALSE,
                main = "Pseudotime Bins",angle_col = 45, show_rownames = T)
}


#绘制ridgeline plot
#首先设置阈值来二值化对特定基因在每个细胞中是否表达
#然后观察表达这个基因的细胞的拟时值分布

get_draw <- function(seuobj, genelist, expr_threshold = 2){
  scale_data <- seuobj@assays[["RNA"]]@scale.data
  df <- c()
  df$pseudotime <- NULL
  df$gene <- NULL
  for (gene in genelist){
    candidate <- rownames(as.data.frame(scale_data[gene,][scale_data[gene,]>expr_threshold]))
    temp <- as.data.frame(seuobj$pseudotime[candidate])
    colnames(temp) <- "pseudotime"
    rownames(temp) <- NULL
    temp$gene <- gene
    df <- rbind(df,temp)
  }
  return(df)
}
```

# 基因拟时表达
## Return:
pseudotime_cells    pseudotime_bins   pseudotime_ridges   pseudotime_ridges2
```{r PseudotimeAnalysis, fig.height=6, fig.width=8}
#选取细胞亚群进行分析
cell.subset <- subset(x = larva,idents = c("DT","SB"),invert = FALSE )
nbins <-  15
cell.subset <- make_bins(cell.subset,nbins)
top_specific_marker_ids <- readRDS("top_specific_marker_ids.RDS")
pseudotime_cells <- make_pseudotime_heatmap_bycells(cell.subset,top_specific_marker_ids,50)
#ggsave(filename = "pseudotime_heatmap_bycells.png", device = png, height = 6, width = 10, plot = pseudotime_cells)

pseudotime_bins <- make_pseudotime_heatmap_average(cell.subset,top_specific_marker_ids,50)
#ggsave(filename = "pseudotime_heatmap_bins.png", device = png, height = 6, width = 10, plot = pseudotime_bins)

df <- get_draw(larva, genelist = head(top_specific_marker_ids,10), expr_threshold = 1)

pseudotime_ridges <- ggplot(df, aes(x = pseudotime , y = gene , fill = gene)) +
 ggridges::geom_density_ridges(alpha = 0.5,show.legend =T) + labs(title = 'DEGs with pseudotime')+
 theme_ipsum() +  theme(legend.position="none", panel.spacing = unit(0.1, "lines"),
                        strip.text.x = element_text(size = 8))
#ggsave(filename = "pseudotime_ridges.png", device = png, height = 8, width = 10, plot = pseudotime_ridges)

pseudotime_ridges2 <- ggplot(df, aes(x = pseudotime, y = gene, fill = ..x..))  +
  geom_density_ridges_gradient(scale = 3, rel_min_height = 0.01,alpha = 0.5) +
  scale_fill_viridis(name = larva$pseudotime, option = "C") +
  labs(title = 'DEGs with pseudotime') + theme_ipsum() +
    theme(
      legend.position="none",
      panel.spacing = unit(0.1, "lines"),
      strip.text.x = element_text(size = 8))
##ggsave(filename = "pseudotime_ridges2.jpg", device = jpeg, height = 8, width = 10, plot = pseudotime_ridges2)

```

# GO
## Return:
GO_plot
```{r GO}
library(org.Dm.eg.db)
for (cl in c("DB","DT","NE","PC","SB","TC","VB")){
  #选择cluster对应的marker
  gene_list <- larva.markers[larva.markers$cluster==cl,]$gene
  #ID转换
  genes <- bitr(gene_list, fromType="SYMBOL",toType=c("ENTREZID","ENSEMBL"),
                   OrgDb = org.Dm.eg.db)
  enrich.go <- enrichGO(gene = genes$ENTREZID, #基因列表文件中的基因名称
                          OrgDb = org.Dm.eg.db,
                          keyType = 'ENTREZID',
                          ont = 'ALL', #可选 BP、MF、CC，也可以指定 ALL 同时计算 3 者
                          pAdjustMethod = 'fdr',
                          pvalueCutoff = 0.05, 
                          qvalueCutoff = 0.2, 
                          readable = TRUE)
  
  GO_plot <- dotplot(enrich.go,title = paste(cl,"GO"),showCategory = 15) + theme_classic() + theme(text = element_text(colour = 'black', size=12))
  ggsave(filename = paste0(cl,"_GO.svg"), device = svg, height = 8, width = 10, plot = GO_plot)
}
# barplot(enrich.go,showCategory = 15) + theme_classic()
# cnetplot(enrich.go)

```

# cellchat
## Return: 
act_weight
chord_plot1   chord_plot2
pathway_heatmap   pathway_chord 
act_bubble1   act_bubble2
```{r cellchat}
cellchatobj <- readRDS("cellchatobj.rds")
groupSize <- as.numeric(table(cellchatobj@idents))
# par(mfrow = c(1,2), xpd=TRUE)
#netVisual_circle(cellchatobj@net$count, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Number of interactions")
act_weight <- netVisual_circle(cellchatobj@net$weight, vertex.weight = groupSize, weight.scale = T, label.edge= F, title.name = "Interaction weights/strength",margin = 0.2)

#chord plot
# par(mfrow = c(1,2), xpd=TRUE)
chord_plot1 <- netVisual_chord_gene(cellchatobj, sources.use = c(6), targets.use = c(1:7), lab.cex = 1, legend.pos.y = 30, legend.pos.x = 10)
chord_plot2 <- netVisual_chord_gene(cellchatobj, sources.use = c(1:7), targets.use = c(6), lab.cex = 1,legend.pos.y = 30, legend.pos.x = 10)


pathways.show <- c("HEDGEHOG signaling pathway") 
# Hierarchy plot

vertex.receiver = seq(1,5) # a numeric vector. 
# netVisual_aggregate(cellchatobj, signaling = pathways.show, layout = "hierarchy",vertex.receiver = vertex.receiver)
# netVisual_aggregate(cellchatobj, signaling = pathways.show, layout = "circle")
pathway_chord <- netVisual_aggregate(cellchatobj, signaling = pathways.show, layout = "chord")


pathways.show <- c("NOTCH signaling pathway") 
par(mfrow=c(1,1))
pathway_heatmap <- netVisual_heatmap(cellchatobj, signaling = pathways.show, color.heatmap = c("#1E90FF","#ff2121")) 
#cellchatobj@netP 对这里的元素画图
pathway_heatmap
```


```{r cellchat act_bubble}
for(i in c(1:7)){
act_bubble1 <- netVisual_bubble(cellchatobj, sources.use = i, targets.use = c(1:7), remove.isolate = FALSE, grid.on = TRUE)+ theme_classic() + geom_point(size = 2) +
  theme(text = element_text(family = NULL, colour = 'black', size=10)) #6 PC作为source
act_bubble2 <- netVisual_bubble(cellchatobj, sources.use = c(1:7), targets.use = i, remove.isolate = FALSE, grid.on = TRUE) + theme_classic() + geom_point(size = 2) + 
  theme(text = element_text(family = NULL, colour = 'black', size=10)) #PC作为target
png(filename = paste0(cellchatobj@idents[i],".png"),width = 3500, height = 1800, res = 500)
print(act_bubble1)
dev.off()
png(filename = paste0(cellchatobj@idents[i],"2.png"),width = 3500, height = 1800, res = 500)
print(act_bubble2)
dev.off()
}
```

```{r function}
FindSubCluster <- function(
  object,
  cluster,
  graph.name,
  subcluster.name = "sub.cluster",
  resolution = 0.5,
  algorithm = 1
) {
  sub.cell <- WhichCells(object = object, idents = cluster)
  sub.graph <- as.Graph(x = object[[graph.name]][sub.cell, sub.cell])
  sub.clusters <- FindClusters(
    object = sub.graph,
    resolution = resolution,
    algorithm = algorithm
  )
  sub.clusters[, 1] <- paste(cluster,  sub.clusters[, 1], sep = "_")
  object[[subcluster.name]] <- as.character(x = Idents(object = object))
  object[[subcluster.name]][sub.cell, ] <- sub.clusters[, 1]
  return(object)
}
```

#Subcluster
## Return: 
subumap_plot    DBsubumap   DB_features
```{r}
larva <- FindSubCluster(larva,"DB","RNA_snn",resolution = 0.3)
subumap_plot <- umapplot(larva, group.by = "sub.cluster")
#ggsave(filename = "larva_subumap.svg", device = svg, height = 6, width = 7, plot = subumap_plot) #对svg调整坐标轴

DB <- subset(larva,idents = "DB")
Idents(DB) <- DB$sub.cluster
DBsubumap <- umapplot(DB, group.by = "sub.cluster") + scale_y_continuous(limits = c(-2,8), breaks = NULL) +  scale_x_continuous(limits = c(2,12), breaks = NULL)
#ggsave(filename = "VB_subumap.svg", device = svg, height = 6, width = 7, plot = VBsubumap) #对svg调整坐标轴

#可视化的基因名称
bs <- f("bs", obj = DB) + scale_y_continuous(limits = c(-2,8), breaks = NULL) +  scale_x_continuous(limits = c(2,12), breaks = NULL)
kni <- f("kni", obj = DB) + scale_y_continuous(limits = c(-2,8), breaks = NULL) +  scale_x_continuous(limits = c(2,12), breaks = NULL)

DB_features <- plot_grid(bs, kni, labels = c("C","D"), ncol = 2, nrow = 1, label_size = 18)
```

# 组合图片
```{r}
fig.1left <- plot_grid(umap_plot, markers_heatmap, labels = "AUTO", ncol = 1, nrow = 2, 
                   label_size = 18, rel_heights = c(1, 1), rel_widths = c(1, 1), align = "v")
fig.1 <- plot_grid(fig.1left, dotplot, labels = c("","C"), ncol = 2, nrow = 1, 
                   label_size = 18, rel_heights = c(1, 1),rel_widths = c(1.1, 0.8), align = "v") + theme_void()
ggsave(filename = paste0("fig1r",".png"), device = png, height = 10, width = 16, plot = fig.1)



fig.2 <- mulit_featureplot
ggsave(filename = paste0("fig2",".png"), device = png, height = 10, width = 12, plot = fig.2)


fig.3 <- plot_grid(act_weight, pathway_chord, act_bubble1, act_bubble2, labels = "AUTO", ncol = 2, nrow =2, 
                   label_size = 18,align = "hv" )
ggsave(filename = paste0("fig3",".png"), device = png, height = 10, width = 16, plot = fig.3)

fig.4 <- plot_grid(corheatmap$gtable, labels = "AUTO", label_size = 18, align = "hv" ) + theme_classic() + theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank())
ggsave(filename = paste0("fig4",".png"), device = png, height = 8, width = 8, plot = fig.4)


fig.5upper <-  plot_grid(subumap_plot, DBsubumap, labels = c("A","B"), label_size = 18, ncol = 2, nrow = 1)
fig.5 <- plot_grid(fig.5upper, DB_features, labels = c("",""), rel_widths = c(1, 1), label_size = 18, ncol = 1, nrow = 2)
ggsave(filename = paste0("fig5",".png"), device = png, height = 10, width = 10, plot = fig.5)

fig.6 <-  plot_grid(pseudotime_bins$gtable, pseudotime_ridges, pseudotime_ridges2, labels = "AUTO", ncol = 1, nrow = 3, 
                   label_size = 18) + theme_classic() + theme(axis.line = element_blank(), axis.text = element_blank(), axis.ticks = element_blank(), axis.title = element_blank())
ggsave(filename = paste0("fig6",".png"), device = png, height = 18, width = 10, plot = fig.6)
```
```{r}
pseudotimegenes <- read.csv("./top_specific_marker_ids.csv")
ge <- as.vector(pseudotimegenes)$x
dhm(as.character(ge),larva)
gene_name <- as.character(ge) #可视化的基因名称
figures <- lapply(gene_name, f)
mulit_featureplot <- plot_grid(plotlist = figures, labels = "AUTO", ncol = 7, nrow = 7, label_size = 18)
ggsave(filename = paste0("pseudotime_genes",".png"), device = png, height = 40, width = 40, plot = mulit_featureplot)
```

Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
